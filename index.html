<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Three.js with lil-gui</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://unpkg.com/three@0.128.0/examples/js/controls/TrackballControls.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/lil-gui@0.17.0"></script>
  <style>
    body, html { margin: 0; height: 100%; width: 100%; overflow: hidden; }
    canvas { display: block; }
    .gui-container {
      position: absolute;
      top: 10px;
      left: 10px;
    }
    .playbar {
      position: absolute;
      bottom: 10px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: 10px;
    }
    .frame-info {
      position: absolute; 
      bottom: 10px;
      right: 10px;
      font-family: Arial, sans-serif;
      font-size: 16px;
      color: white;
      text-align: right;
    }
    .file-upload-container {
      position: absolute;
      top: 10px;
      right: 10px;
    }
    .file-upload-container input {
      display: none;
    }
    .file-upload-container label {
      background-color: #000000;
      color: white;
      padding: 10px;
      border-radius: 5px;
      cursor: pointer;
    }
  </style>
</head>
<body>
  <div id="gui-container" class="gui-container"></div>
  <div class="playbar">
    <button id="play-pause">Play</button>
    <button id="step-back">Step Back</button>
    <button id="step-forward">Step Forward</button>
  </div>
  <div class="frame-info" id="frame-info"></div>
  <div class="file-upload-container">
    <input type="file" id="file-input" accept=".json">
    <label for="file-input">Load JSON</label>
  </div>

  <script>
    let scene, camera, renderer, controls, pointLight;
    let isPlaying = false;
    let currentFrame = 1;
    let animationLength = 1500; // Default animation length
    let decimalYear = 1995;
    let spheres = [];
    let jsonData = [];
    let sphereRadius = 25;
    let eventWindow = 0.2;
    const frameInfo = document.getElementById('frame-info');
    let frameSliderController;

    init();
    animate();

    function init() {
      // Create scene
      scene = new THREE.Scene();

      // Create camera
      camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 10000);
      camera.position.z = 100;

      // Create renderer
      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.outputEncoding = THREE.sRGBEncoding;
      document.body.appendChild(renderer.domElement);

      // Add controls
      controls = new THREE.TrackballControls(camera, renderer.domElement);

      // Add point light
      pointLight = new THREE.PointLight(0xffffff, 1);
      scene.add(pointLight);

      // Add axis gnomon
      addAxisGnomon();

      // Handle window resize
      window.addEventListener('resize', onWindowResize);

      // GUI setup
      setupGUI();

      // Playbar button actions
      document.getElementById('play-pause').addEventListener('click', togglePlayPause);
      document.getElementById('step-back').addEventListener('click', stepBack);
      document.getElementById('step-forward').addEventListener('click', stepForward);

      // File input change event
      document.getElementById('file-input').addEventListener('change', handleFileUpload);

      // Load default JSON data
      loadDefaultJSON();
    }

    function setupGUI() {
      const gui = new lil.GUI({ container: document.getElementById('gui-container') });
      gui.addColor({ backgroundColor: '#000000' }, 'backgroundColor').onChange((value) => {
        renderer.setClearColor(value);
      });

      gui.add({ sphereRadius: sphereRadius }, 'sphereRadius', 1, 200).onFinishChange((value) => { // Updated max to 200
        sphereRadius = value;
        updateSpheres(false); // Update spheres without recalculating the bounding box
      });

      frameSliderController = gui.add({ frameSlider: currentFrame }, 'frameSlider', 1, animationLength, 1).name('Frame').onChange((value) => {
        currentFrame = value;
        decimalYear = 1995 + (value - 1) * (2020 - 1995) / (animationLength - 1);
        updateSphereColors();
        updateFrameInfo();
      });

      gui.add({ eventWindow: eventWindow }, 'eventWindow', 0.05, 1.0, 0.01).name('Event Window').onChange((value) => {
        eventWindow = value;
        updateSphereColors();
      });

      gui.add({ animationLength: animationLength }, 'animationLength', 30, 3000, 1).name('Animation Length').onChange((value) => {
        animationLength = value;
        currentFrame = 1;
        decimalYear = 1995 + (currentFrame - 1) * (2020 - 1995) / (animationLength - 1);
        frameSliderController.max(animationLength); // Update the max value of the frame slider
        updateSphereColors();
        updateFrameInfo();
      });

      gui.add({ resetView: resetView }, 'resetView').name('Reset View');
    }

    function onWindowResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }

    function animate() {
      requestAnimationFrame(animate);
      controls.update();
      pointLight.position.copy(camera.position); // Update the light position to follow the camera
      renderer.render(scene, camera);

      if (isPlaying) {
        currentFrame = (currentFrame % animationLength) + 1;
        decimalYear = 1995 + (currentFrame - 1) * (2020 - 1995) / (animationLength - 1);
        updateSphereColors();
        updateFrameInfo();
        frameSliderController.setValue(currentFrame); // Update the GUI slider
        controls.dispatchEvent({ type: 'change' }); // Ensures TrackballControls updates
      }
    }

    function handleFileUpload(event) {
      const file = event.target.files[0];
      const reader = new FileReader();
      reader.onload = (e) => {
        try {
          jsonData = JSON.parse(e.target.result);
          updateSpheres(true);
          updateSphereColors();
          resetView();
        } catch (error) {
          console.error('Error parsing JSON:', error);
        }
      };
      reader.readAsText(file);
    }

    function loadDefaultJSON() {
      fetch('assets/hakone.json')
        .then(response => response.json())
        .then(data => {
          jsonData = data;
          updateSpheres(true);
          updateSphereColors();
          resetView();
        })
        .catch(error => console.error('Error loading default JSON:', error));
    }

    function updateSpheres(recalculateBoundingBox = false) {
      // Remove only the previously added spheres
      const toRemove = [];
      scene.traverse((object) => {
        if (object.userData.type === 'dynamic') {
          toRemove.push(object);
        }
      });
      toRemove.forEach((object) => scene.remove(object));

      if (jsonData.length === 0) {
        console.warn('No JSON data available to render.');
        return;
      }

      const positions = jsonData.map(item => {
        const x = parseFloat(item.easting);
        const y = parseFloat(item.depth);
        const z = -parseFloat(item.northing);

        if (isNaN(x) || isNaN(y) || isNaN(z)) {
          console.error('Invalid position data:', item);
          return null;
        }

        return {
          position: new THREE.Vector3(x, y, z),
          decimalYear: parseFloat(item.decimal_year)
        };
      }).filter(pos => pos.position !== null);

      if (positions.length === 0) {
        console.warn('No valid positions to render.');
        return;
      }

      if (recalculateBoundingBox) {
        const boundingBox = new THREE.Box3();

        positions.forEach(pos => {
          boundingBox.expandByPoint(pos.position);
        });

        console.log('Bounding Box:', boundingBox);

        // Remove existing bounding box and labels
        scene.traverse((object) => {
          if (object.userData.type === 'boundingBox' || object.userData.type === 'label') {
            scene.remove(object);
          }
        });

        // Add new bounding box
        const boxGeometry = new THREE.BoxGeometry(
          boundingBox.max.x - boundingBox.min.x,
          boundingBox.max.y - boundingBox.min.y,
          boundingBox.max.z - boundingBox.min.z
        );
        const wireframe = new THREE.EdgesGeometry(boxGeometry);
        const lineMaterial = new THREE.LineBasicMaterial({ color: 0xffffff });
        const boundingBoxMesh = new THREE.LineSegments(wireframe, lineMaterial);
        boundingBoxMesh.position.copy(boundingBox.getCenter(new THREE.Vector3()));
        boundingBoxMesh.userData.type = 'boundingBox';
        scene.add(boundingBoxMesh);

        // Add tick marks and labels
        addTickMarksAndLabels(boundingBox);

        controls.target.copy(boundingBox.getCenter(new THREE.Vector3()));
        controls.update();
      }

      const geometry = new THREE.SphereGeometry(sphereRadius, 32, 32);
      positions.forEach(pos => {
        const material = new THREE.MeshPhongMaterial();
        const sphere = new THREE.Mesh(geometry, material);
        sphere.position.copy(pos.position);
        sphere.userData.type = 'dynamic';
        sphere.userData.decimalYear = pos.decimalYear;
        scene.add(sphere);
        spheres.push(sphere);
      });

      if (recalculateBoundingBox) {
        resetView();  // Ensure the view is reset after updating spheres
      }
    }

    function addTickMarksAndLabels(boundingBox) {
      const tickSpacing = 100;
      const textSize = 10;
      const labelColor = 0xffffff;

      const createLabel = (text, position) => {
        const canvas = document.createElement('canvas');
        const context = canvas.getContext('2d');
        context.font = `${textSize}px Arial`;
        context.fillStyle = 'white';
        context.fillText(text, 0, textSize);

        const texture = new THREE.CanvasTexture(canvas);
        const material = new THREE.SpriteMaterial({ map: texture });
        const sprite = new THREE.Sprite(material);
        sprite.position.copy(position);
        sprite.scale.set(30, 15, 1); // Adjust scale as needed
        sprite.userData.type = 'label';
        return sprite;
      };

      for (let x = Math.ceil(boundingBox.min.x / tickSpacing) * tickSpacing; x <= boundingBox.max.x; x += tickSpacing) {
        const tick = new THREE.Line(new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(x, boundingBox.min.y, boundingBox.min.z), new THREE.Vector3(x, boundingBox.min.y, boundingBox.min.z + 10)]), new THREE.LineBasicMaterial({ color: labelColor }));
        tick.userData.type = 'label';
        scene.add(tick);
        const label = createLabel(x.toString(), new THREE.Vector3(x, boundingBox.min.y - 20, boundingBox.min.z));
        scene.add(label);
      }

      for (let y = Math.ceil(boundingBox.min.y / tickSpacing) * tickSpacing; y <= boundingBox.max.y; y += tickSpacing) {
        const tick = new THREE.Line(new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(boundingBox.min.x, y, boundingBox.min.z), new THREE.Vector3(boundingBox.min.x + 10, y, boundingBox.min.z)]), new THREE.LineBasicMaterial({ color: labelColor }));
        tick.userData.type = 'label';
        scene.add(tick);
        const label = createLabel(y.toString(), new THREE.Vector3(boundingBox.min.x - 20, y, boundingBox.min.z));
        scene.add(label);
      }

      for (let z = Math.ceil(boundingBox.min.z / tickSpacing) * tickSpacing; z <= boundingBox.max.z; z += tickSpacing) {
        const tick = new THREE.Line(new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(boundingBox.min.x, boundingBox.min.y, z), new THREE.Vector3(boundingBox.min.x, boundingBox.min.y + 10, z)]), new THREE.LineBasicMaterial({ color: labelColor }));
        tick.userData.type = 'label';
        scene.add(tick);
        const label = createLabel(z.toString(), new THREE.Vector3(boundingBox.min.x - 20, boundingBox.min.y, z));
        scene.add(label);
      }
    }

    function updateSphereColors() {
      spheres.forEach(sphere => {
        const yearDifference = sphere.userData.decimalYear - decimalYear;
        if (yearDifference > 0 && yearDifference < eventWindow) {
          sphere.material.color.set(0xff0000);
        } else {
          sphere.material.color.set(0xffffff);
        }
      });
    }

    function addAxisGnomon() {
      const axisLength = 50;
      const axesHelper = new THREE.AxesHelper(axisLength);
      axesHelper.position.set(-window.innerWidth / 2 + 60, -window.innerHeight / 2 + 60, 0);
      scene.add(axesHelper);
    }

    function resetView() {
      const boundingBox = new THREE.Box3().setFromObject(scene);
      if (boundingBox.isEmpty()) return;  // Do nothing if there's no bounding box

      const center = boundingBox.getCenter(new THREE.Vector3());
      const size = boundingBox.getSize(new THREE.Vector3());
      const maxDim = Math.max(size.x, size.y, size.z);
      const fov = (camera.fov * Math.PI) / 180; // Convert FOV from degrees to radians
      let cameraZ = Math.abs(maxDim / 2 / Math.tan(fov / 2));
      cameraZ *= 2; // Adjust the factor to ensure the camera is outside the bounding box

      console.log('Bounding Box:', boundingBox);
      console.log('Center:', center);
      console.log('Size:', size);
      console.log('Max Dimension:', maxDim);
      console.log('Calculated Camera Z:', cameraZ);

      controls.reset(); // Reset controls before calculating the camera position

      camera.position.set(center.x, center.y, center.z + cameraZ);
      camera.near = maxDim / 1000;
      camera.far = maxDim * 10;
      camera.updateProjectionMatrix();
      camera.lookAt(center);

      const distance = camera.position.distanceTo(center);
      console.log('Distance from Camera to Center:', distance);

      controls.target.copy(center);
      controls.update();
    }

    function togglePlayPause() {
      isPlaying = !isPlaying;
      document.getElementById('play-pause').textContent = isPlaying ? 'Pause' : 'Play';
    }

    function stepForward() {
      currentFrame = (currentFrame % animationLength) + 1;
      decimalYear = 1995 + (currentFrame - 1) * (2020 - 1995) / (animationLength - 1);
      updateSphereColors();
      updateFrameInfo();
      frameSliderController.setValue(currentFrame); // Update the GUI slider
    }

    function stepBack() {
      currentFrame = currentFrame === 1 ? animationLength : currentFrame - 1;
      decimalYear = 1995 + (currentFrame - 1) * (2020 - 1995) / (animationLength - 1);
      updateSphereColors();
      updateFrameInfo();
      frameSliderController.setValue(currentFrame); // Update the GUI slider
    }

    function updateFrameInfo() {
      frameInfo.innerHTML = `Frame: ${currentFrame} / ${animationLength}<br>Decimal Year: ${decimalYear.toFixed(4)}`;
    }
  </script>
</body>
</html>
